## 索引失效问题（如何避免）

### 索引失效案例

**1、最左匹配原则**

建立组合索引时，如果使用该索引，必须要按顺序查询

![1552028974532](C:\Users\S1\AppData\Roaming\Typora\typora-user-images\1552028974532.png)

通过ref可以看到，3列都使用到了索引。

![1552029247374](C:\Users\S1\AppData\Roaming\Typora\typora-user-images\1552029247374.png)

而如果不查询`name`，只查询`age`和`pos`，是无法使用索引的，即组合索引必须按建立顺序进行查询。

**2、不要在索引列上做任何操作，否则会导致索引失效转全表扫描**

操作指：计算，统计，函数，类型转换等等

![1552029659439](C:\Users\S1\AppData\Roaming\Typora\typora-user-images\1552029659439.png)

如图所示的sql，使用了`left()`函数，便导致索引失效

**3、存储引擎不能使用索引中范围条件右边的列**

这也是索引的最左匹配原则里规定的

![1552030435672](C:\Users\S1\AppData\Roaming\Typora\typora-user-images\1552030435672.png)

从`type`为`range`与长度可知，索引命中了`name`与`age`，但是并没有命中`pos`，这正证明了最左匹配原则，范围查询后的列无法命中索引。

**4、尽量使用覆盖索引（只查询与索引列一致的列），减少select ** *

![1552030886191](C:\Users\S1\AppData\Roaming\Typora\typora-user-images\1552030886191.png)

可以看到附加信息中`using index`，说明效率更高

**5、mysql在使用不等于（!=或<>）会导致失效**

**6、is null，is not null 无法使用索引**

**7、like以通配符开头（'%李...'）会导致索引失效**

![1552031591246](C:\Users\S1\AppData\Roaming\Typora\typora-user-images\1552031591246.png)

由图可知，索引失效且全表扫描，那么，工作过程中，必须使用双百分号才可以如何解决呢？

使用**覆盖索引查询**，查询时直接查询被索引覆盖的列，而不是查询*

![1552031686140](C:\Users\S1\AppData\Roaming\Typora\typora-user-images\1552031686140.png)

**8、字符串不加单引号会索引失效**

![1552033276905](C:\Users\S1\AppData\Roaming\Typora\typora-user-images\1552033276905.png)

如图，varchar类型的name没有使用单引号，mysql会隐式类型转换（可参考第二项），会导致索引失效

**9、使用or连接会导致索引失效**

![1552033391253](C:\Users\S1\AppData\Roaming\Typora\typora-user-images\1552033391253.png)

