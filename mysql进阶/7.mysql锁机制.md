## 一、锁介绍

锁：是一种管理多线程或进程并发访问某一资源的机制。

### 锁的分类：

- 数据操作类型分类
  - 读锁（共享锁）
  - 写锁（排他锁）
- 数据操作粒度分类
  - 表锁
  - 行锁

## 二、表锁（偏读）

看到表锁立马想到了MyISAM数据库引擎，因为它便是使用的表锁。

表锁开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高，并发度最小。

### 表锁中的读写锁

#### 读锁：

如果一个会话加了读锁，那么这个会话**可以进行读操作，不可以进行写操作**

其他会话**可以进行读操作，写操作会阻塞直到锁为释放**

#### 写锁：

如果一个会话加了写锁，那么这个**会话可以进行读写操作**

其他会话**进行读写操作都会被阻塞直到锁释放**

### 总结：

MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。 
MySQL的表级锁有两种模式：
 **表共享读锁**（Table Read Lock）
 **表独占写锁**（Table Write Lock）

| 锁类型 | 他人可读 | 他人可写 |
| ------ | -------- | -------- |
| 读锁   | 是       | 否       |
| 写锁   | 否       | 否       |

 结合上表，所以对MyISAM表进行操作，会有以下情况： 
  1、对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。 
  2、对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。
 **简而言之，就是读锁会阻塞写，但是不会堵塞读。而写锁则会把读和写都堵塞**

## 三、行锁（偏写）

一般行锁用于InnoDB引擎中，是**支持事物的一种锁**

行锁具有开销大，加锁慢，会出现死锁，并发度高，锁冲突概率小的特点

在行锁中也具有**共享锁与排他锁**，只不过针对的是每一行，其特点与表读锁表写锁类似。

### 索引问题导致行锁升级为表锁

正常情况下，行与行之间互不影响，但是如果在某字段加了索引，而因为特殊原因索引失效，那么会导致行锁升级为表锁。例如：

`update test set b = '2' where b = 200`可知，varchar类型如果没有用引号会导致索引失效，这时别的行进行修改也会被阻塞

### 总结

Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在**整体并发处理能力方面要远远优于**MyISAM的表级锁定的。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。

但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会更差。

## 四、间隙锁

### 什么是间隙锁

当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，
InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（GAP Lock）。

`update test set b = '2' where a > 2 and a < 5`这样的一个sql语句，如果其他的会话想对`a=3`这个数据进行写操作，就会被阻塞。

### 危害

因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。
间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害