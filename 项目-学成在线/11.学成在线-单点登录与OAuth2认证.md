## 单点登录

之前我们搭建了很多的服务，前端或后端工程，比如CMS管理平台，课程管理平台，学成在线首页，学习中心等服务。但是我们都没有实现用户功能。即用户登录认证。

如果我们在每个服务都添加自己的认证服务，那么用户在学成网登陆了，想进去学习中心学习因为相互独立，所以登录状态也相互独立，就会再次出现登录请求，非常不友好，单点登录就是在一个系统登录后，其他系统也可以进行认证。即**一次登录，访问多个系统**。

![1583733889629](../image/1583733889629.png)

### 单点登陆实现技术方案

![1583734075084](../image/1583734075084.png)

再开发一个统一认证系统，其他系统访问此系统进行认证

- 如果用户没登录，转发登陆页（可以是用户密码登录，手机号登录，QQ登录，微信登录等），登录成功后保存用户信息到Redis中
- 如果用户已经登录，返回给其他系统令牌，标识用户信息及已经登录

Java有很多框架可以实现这样一个单点登录的需求：

- Shiro
- CAS
- Spring Security

这里我们使用SpringSecurity，没有了解过的可以看一下[SpringSecurity笔记](<https://pacee1.github.io/categories/springsecurity/>)

## OAuth2协议

OAuth2协议是解决认证协议的标准，因为不同系统需要进行认证，肯定要遵循一定的规则，OAuth2协议的诞生，就是解决这种规则问题的。

具体协议规则可以看一下笔记：[SpringSecurity-Social-基本原理](<https://pacee1.github.io/2020/01/09/ss09-SpringSecurity09-Social-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/>)

OAuth授权码模式

![1583735211343](../image/1583735211343.png)

对应我们学成在线来说，第三方应用就是学成在线，服务提供商就是微信

![1583735194628](../image/1583735194628.png)

### SpringSecurity OAuth2认证授权解决方案

![1583735988048](../image/1583735988048.png)

如图，上半部分是认证，下半部分为授权

- 认证

1. 前端请求SpringSecurity认证服务器进行认证
2. 认证服务器请求微信，获取授权码，通过授权码获取令牌，通过令牌拿到资源，生成JWT令牌（JWT：存储用户信息的Token）
3. 认证通过后返回JWT令牌给浏览器
4. 浏览器拿着JWT请求各个微服务
5. 服务网管（Zuul）进行令牌校验，访问Redis（认证服务会把令牌保存到Redis），判断是否一致
6. 认证不通过打回，认证通过放行

- 授权

7. 认证通过后，各个微服务通过JWT令牌判断该用户是否有权限操作
8. 有权限执行返回结果，没有权限打回

## 认证服务器搭建及使用

### 搭建

搭建很简单，项目中查看`xc-service-ucenter-auth`

里面有一些配置，都是和SpringSecurity有关的，后面用到的时候再说

然后就说数据库的创建，直接执行`xc-resource`里的`xc-user.sql`

然后就可以启动了，启动后，就说一个认证服务器，这个认证服务器主要就是认证获取Token，JWT

### 申请授权码

```
Get
localhost:40400/auth/oauth/authorize?client_id=XcWebApp&response_type=code&scope=app&redirect_uri=http://localhost
```

其中`/auth`是应用服务配置的`contextPath`，SpringSecurity OAuth2提供的请求路径为`/oauth/authorize`，请求参数是（请求参数也是OAuth2规定的）：

- `client_id`：请求客户端应用的ID，这个ID需要保存在数据库`oauth_client_details`表中
- `response_type`：OAuth认证模式，`code`为授权码模式
- `scope`：和数据库一样，这个不重要
- `redirect_uri`：申请成功后回调地址

认证成功后，会返回授权码，格式为：

```
redirect_uri + ?code=xxx
```

#### 测试

访问后进入登录页面

![1583742563966](../image/1583742563966.png)

此用户名密码就是数据库保存的，其中密码进行了加密

![1583742592557](../image/1583742592557.png)

![1583742620517](../image/1583742620517.png)

进行认证，点击`Authorize`，即通过认证

![1583742666428](../image/1583742666428.png)

返回回调地址，这里的code就是授权码 `mREck0`

### 申请令牌

```
Post http://localhost:40400/auth/oauth/token
在form-data中添加
grant_type: authorization_code
code:mREck0
redirect_uri: http://localhost
```

`/oauth/token`为SpringSecurity OAuth2规定的申请令牌的请求URL，参数为：

- `grant_type`：认证模式，授权码模式为`authorization_code`
- `code`：刚刚获取的授权码
- `redirect_uri`：回调地址，**注意要和刚刚获取授权码的一样**

**还有一个重要的，就是在请求上添加`Authorization`：**

![1583744327373](../image/1583744327373.png)

这样他就会在header中添加用户名密码，进行认证，比如下：

`Authorization：Basic WGNXZWJBcHA6WGNXZWJBcHA=`

请求成功后返回的数据：

```json
{
  "access_token": "xxx",
  "token_type": "bearer",
  "refresh_token": "xxx",
  "expires_in": 43199,
  "scope": "app",
  "jti": "6081830d-d9e7-448d-b8d9-bd1ac20899b2"
}
```

最重要的就是`access_token`，令牌，`expires_in`是有效时间，`refresh_token`用来刷新令牌

**到此 认证服务器的工作就完成了**

### 资源服务授权

#### 授权流程

![1583743448524](../image/1583743448524.png)

其中客户端是前端工程，授权服务是刚刚搭建的`xc-service-ucenter-auth`，资源服务是我们之前写的课程模块，cms模块，搜索模块等等

流程：

- 首先客户端请求认证服务器拿到JWT令牌，认证服务采用非对称加密算法，使用私钥生成令牌。
- 然后客户端携带JWT请求资源服务器
- 资源服务器通过公钥校验令牌合法性，如果合法，执行接口，返回资源
- 这样做的好处是防止网络通信间，令牌被不法分子串改，比如修改其中用户信息为已经购买课程的用户，这样就可以免费看视频了

#### 授权配置

在之前，我们的课程服务所有人都可以访问，并没有任何认证，这里我们将它集成SpringSecurity来进行请求前认证

**添加公钥**

因为是非对称加密，所以我们需要公钥进行JWT的校验

将公钥放在`resources`路径下

![1583743905736](../image/1583743905736.png)

**添加依赖**

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-oauth2</artifactId>
</dependency>
```

**添加配置类**

`ResourceServerConfig`配置类，主要是用来配置JWT令牌，以及JWT校验的公钥，以及SpringSecurity的一些http安全配置，比如添加某些路径直接放行，不进行认证

```java
@Configuration
@EnableResourceServer
@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)//激活方法上的PreAuthorize注解
public class ResourceServerConfig extends ResourceServerConfigurerAdapter {

    //公钥
    private static final String PUBLIC_KEY = "publickey.txt";

    //定义JwtTokenStore，使用jwt令牌
    @Bean
    public TokenStore tokenStore(JwtAccessTokenConverter jwtAccessTokenConverter) {
        return new JwtTokenStore(jwtAccessTokenConverter);
    }

    //定义JJwtAccessTokenConverter，使用jwt令牌
    @Bean
    public JwtAccessTokenConverter jwtAccessTokenConverter() {
        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
        converter.setVerifierKey(getPubKey());
        return converter;
    }
    /**
     * 获取非对称加密公钥 Key
     * @return 公钥 Key
     */
    private String getPubKey() {
        Resource resource = new ClassPathResource(PUBLIC_KEY);
        try {
            InputStreamReader inputStreamReader = new InputStreamReader(resource.getInputStream());
            BufferedReader br = new BufferedReader(inputStreamReader);
            return br.lines().collect(Collectors.joining("\n"));
        } catch (IOException ioe) {
            return null;
        }
    }
    //Http安全配置，对每个到达系统的http请求链接进行校验
    @Override
    public void configure(HttpSecurity http) throws Exception {
        //所有请求必须认证通过
        http.authorizeRequests()
                //下边的路径放行
                .antMatchers("/v2/api-docs", "/swagger-resources/configuration/ui",
                        "/swagger-resources","/swagger-resources/configuration/security",
                        "/swagger-ui.html","/webjars/**").permitAll()
                .anyRequest().authenticated();
    }
}
```

#### 授权测试

启动课程模块后，访问之前编写的查询课程信息的接口

![1583744243186](../image/1583744243186.png)

会发现提示你没有通过认证，说明我们SpringSecurity集成成功

然后我们在使用postman工具，在请求Header上添加令牌，添加格式为：注意`Bearer`和`Token`间有个空格

```
Authorization: Bearer JWToken
```

![1583744502219](../image/1583744502219.png)

成功请求



### 校验和刷新令牌

校验令牌：

```
Get: http://localhost:40400/auth/oauth/check_token?token=
```

刷新令牌：

```
Post：http://localhost:40400/auth/oauth/token
参数：
grant_type ： 固定为 refresh_token
refresh_token：刷新令牌（注意不是access_token，而是refresh_token）
```



## JWT令牌

### JWT介绍

首先我们看看普通Token令牌

![1583745267099](../image/1583745267099.png)

看着没啥问题，但是有比较严重的缺点：资源服务拿到令牌后，无法确定令牌是否合法，必须请求认证服务来判断合法性，因为令牌是由认证服务创建的，资源服务并不知道其中的生成规则，这样就会影响性能，多了一层请求调用。

再看一下JWT令牌

![1583745363142](../image/1583745363142.png)

JWT是一种标准，自身保存了一些json对象信息，并且它本身保存了加密规则，并且进行数字签名，让别人如果修改了内容，也无法校验成功

这样资源服务拥有公钥，就可以进行校验，省去了再次请求认证服务的时间。

### JWT构成以及为何安全

JWT由三部分构成，在生成的令牌中用`.`来分隔，xxxx.yyyyy.zzzzz

#### 第一部分Header

头部令牌，用来保存令牌类型以及使用的加密算法

```
{
  'typ': 'JWT',
  'alg': 'HS256'
}
```

然后将头部进行base64加密（该加密是可以对称解密的），构成了第一部分

```
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
```

#### 第二部分Payload

存储有效数据的地方，可以把一些用户信息放在里面，它可以存放jwt提供的现成字段，比如：iss（签发者）,exp（过期时间戳）, sub（面向的用户）等，也可自定义字段。

此部分不建议存放敏感信息，**因为此部分可以解码还原原始内容**。

```java
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

然后将其进行base64加密，得到JWT的第二部分：

```java
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9
```

#### 第三部分Signature

第三部分是签名，此部分用于防止jwt内容被篡改。

这个部分需要base64后的`hander`和base64后的`payload`使用.连接组成的字符串，然后通过hander中声明的加密方式进行加盐`secret`组合加密，然后就构成了jwt的第三部分。

```java
// java
String encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload);
String signature = HMACSHA256(encodedString, secret); 
```

将这三部分用.连接成一个完整的字符串,构成了最终的jwt

#### 为何安全

可以看到它将加密规则存放在了第一部分，那还安全吗？随便解码一下不就知道了？

是的，所以不要把敏感信息存到里面，比如密码等，那为什么安全？

因为`它不能被篡改`，如果有人想修改用户信息，来进行非法请求，因为`secret`的存在，所以它后期进行签名的JWT一定通不过校验，因为`secret`不同，编码后的字符串也是不同的。

**所以一定要保存好secret**



### JWT私钥与公钥生成

#### 生成私钥

命令行执行以下代码，它是Java提供的一个工具类，所以有Java环境即可

```
keytool -genkeypair -alias xckey -keyalg RSA -keypass xuecheng -keystore xuecheng.keystore -storepass xuechengkeystore
```

-alias：密钥的别名

-keyalg：使用的hash算法

-keypass：密钥的访问密码

-keystore：密钥库文件名，xc.keystore保存了生成的证书

-storepass：密钥库的访问密码

![1583747358057](../image/1583747358057.png)

#### 导出公钥

首先需要一个openssl加解密工具包，下载 Win64OpenSSL-1_1_0g.exe安装，配置环境变量

然后再刚刚生成的私钥目录下打开cmd

```
keytool -list -rfc --keystore xuecheng.keystore | openssl x509 -inform pem -pubkey
```

![1583747639335](../image/1583747639335.png)

然后将公钥部分保存，红框中，保存在一行

这样公钥私钥就生成完毕

接着就可以把私钥放到认证服务器资源目录下，SpringSecurity就会读取并进行签名加密。

公钥放到资源服务器，进行校验JWT。





