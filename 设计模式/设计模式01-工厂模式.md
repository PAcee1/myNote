# 工厂模式

## 工厂模式的诞生

首先，我们举个例子，来说明工厂模式能干什么，有什么好处，具体是怎么实现的？

### 面包店的故事

在很久很久以前，有3个商人，合伙开一个面包店。

一个面包的制作过程繁琐，为：和面 -》 添加调味料 -》 做雏形 -》 烤箱烤 -》 做好了封装起来

1. 最开始，三个人手工制作，每天供应100个，并且累死累活
2. 生意好起来之后，为了减少劳动量，开了个面包坊，并招聘面包师傅来做，但是为了面包和之前做的一样，需要一个人去教面包师傅具体的制作心得，这样每天供应1000个，并且教会师傅后，就可以歇息了
3. 生意越做越大，后面开了面包工厂，面包师傅都不要了，直接让机器来生产面包，设置好机器的操作，工厂的员工只需操作机器，按照流水线（每个制作过程为一条流水线），进行一步步生产，这样三个商人天天就躺着收钱了。

上面举了个例子形容了工厂模式，接着我们总结一下

- 手工自作：耗时耗力；商人制作需要知道面包怎么做
- 面包坊：增加效率，减少了工作量；面包师傅还是需要知道面包怎么做
- 工厂：大大增加效率，减少人力；工人不需要知道面包怎么做，只需给机器下命令，然后等着收面包就可以。

### 面包店的总结

从最初商人自己做，到后面开工厂机器生产，解决了什么问题呢？对于我们代码来说又有什么帮助呢？

- 效率问题，大大提升效率，这里不管对做面包还是写代码都一样
- **用户与产品的问题**：
  - 用户不需要知道产品的制作方式，只需一个命令，就可以拿到结果，通过关注过程转成了关注结果
  - **比如Spring的`BeanFactory`**，调用时传入类名，就可以获取这个类的实例，不需要知道这个类应该如何构造。

## 简单工厂模式

简单工厂模式，又叫做静态工厂模式，不属于23种之一，是比较简单的一种设计模式。

简单工厂模式实质，就是由一个工厂根据传入参数的不同，制作出不同产品，对象。

比如Spring的BeanFactory，传入一个beanName就可以获取到Bean对象，但是BeanFactory不是简单工厂模式，他的实现更复杂。

| 归类   | 特点                 | 穷举             |
| ------ | -------------------- | ---------------- |
| 创建型 | 是复杂工程的思维模型 | 批量生产，标准化 |

### 代码实现

首先需要创建实体，这里我们拿牛奶举例子，需要创建一个Milk接口实体类，然后创建蒙牛和伊利的实体

简单工厂实现：

```java
public class SimpleFactory {

    public Milk getMilk(String milkName){
        if(milkName.equals("蒙牛")){
            return new MengNiuMilk();
        }else if(milkName.equals("伊利")){
            return new YiLiMilk();
        }
        return null;
    }
}
```

测试类：

```java
public class SimpleFactoryTest {
    public static void main(String[] args) {
        // 创建一个简单牛奶工厂
        SimpleFactory milkFactory = new SimpleFactory();

        // 获取牛奶，通过名称获取
        System.out.println(milkFactory.getMilk("蒙牛"));
    }
}
```

这样的话，我们就可以只传入名称，就通过工厂获取到牛奶了，而**对于不同牛奶制作方法（比如水和奶和糖的配比）都是在工厂内部完成的，用户不需要知道**。



![1585559882718](/image/1585559882718.png)



## 工厂方法模式

工厂方法模式是简单工厂模式的进阶，我们很容易的发现，简单工厂模式是违反开闭原则的，当想要扩展时，必须修改工厂中的方法。

工厂方法模式是**工厂定义抽象方法，该方法由子工厂来实现**，可以理解为创建对象的操作推到子类完成，而不是基类直接完成。

### 工厂方法模式的实现

以牛奶为例：

1. 定义牛奶接口，并定义多种牛奶
2. 定义一个牛奶工厂接口
3. 创建多个实际的牛奶工厂，比如伊利蒙牛等

![1585556969481](/image/1585556969481.png)



这样的话，如果我们想要扩展工厂，只需新建实现类即可，满足开闭原则



![1585559951032](/image/1585559951032.png)



## 抽象工厂模式

抽象工厂是在工厂方法模式上进行扩展，添加了产品种类。

之前，我们只能从工厂中拿到牛奶，添加了产品种类的意思就是可以拿酸奶等其他奶制品。

每一个模式都是针对一定问题的解决方案，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式针对的是**多个产品等级结构**，工厂方法模式也可以说是抽象工厂模式的简单实现。

总结一下我认为可以应用到抽象工厂模式的实际例子：

*1. 两种产品：PC和MAC，两种产品等级：RAM，CPU*

*2. 两种产品：水果和蔬菜，两种产品等级：南方特产，北方特产*

*3. 两种产品：男人和女人，三种产品等级：黄种人，黑人，白人*

就类似这种结构的对象关系都可以用抽象工厂模式来构造。。。。。

### 抽象工厂模式的实现

1. 创建牛奶和酸奶接口，并创建一些实现类，比如蒙牛牛奶，伊利酸奶等等
2. 定一个奶制品总工厂，并提供牛奶和酸奶的接口
3. 创建蒙牛和伊利产品线（子类），编写牛奶酸奶具体实现



工厂：

```java
public interface AbstartFactory {// 这里也可以使用抽象类而不是接口，抽象类可以写一些公共方法
    Milk getMilk();

    Yogurt getYogurt();
}

public class YiLiFactory implements AbstartFactory {
    public Milk getMilk() {
        return new YiLiMilk();
    }

    public Yogurt getYogurt() {
        return new YiLiYogurt();
    }
}

public class MengNiuFactory implements AbstartFactory {
    public Milk getMilk() {
        return new MengNiuMilk();
    }

    public Yogurt getYogurt() {
        return new MengNiuYogurt();
    }
}
```

测试类：

```java
public class AbstractFactoryTest {

    public static void main(String[] args) {
        // 去工厂取伊利奶制品
        AbstartFactory milkFactory = new YiLiFactory();
        milkFactory.getMilk(); // 获取牛奶
        milkFactory.getYogurt(); // 获取酸奶
    }
}
```

![1585560142629](/image/1585560142629.png)



## 工厂模式总结

对于简单工厂模式来说：

**不满足开闭原则**，用户使用工厂获取对象时需要完全写对参数。

对于工厂方法模式来说：

**满足开闭原则**，用户不需要完全写对入参，只需根据需要实现具体的工厂，来获取对象

对于抽象工厂来说：

- **如果扩展产品种类，不满足开闭原则**，因为要修改很多，基类中需要添加产品，并且实现类也需要添加
- **如果扩展产品角色，满足开闭原则**，只需创建类实现基类即可
- **当抽象工厂只有一种产品种类时，就自动变成工厂方法模式**



总的来说：

- 设计模式是为了处理复杂问题的，如果把简单问题复杂化，强行使用设计模式，就得不偿失了
- 简单工厂：创建对象过程简单，但是需要匹配不同请求，返回不同对象时使用
- 工厂方法：创建对象过程复杂，并且只需要单一种类的
- 抽象工厂：多产品角色多产品种类，非常复杂的对象构造时使用

